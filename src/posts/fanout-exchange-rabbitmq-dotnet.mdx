---
title: RabbitMQ Fanout Exchange Explained
slug: fanout-exchange-rabbitmq-dotnet
date: '2024-03-21'
feature_image: /content/images/2024/03/RabbitMQ---Fanout-Exchange.png
tags:
  - RabbitMQ
  - AWS
excerpt: >-
  A Fanout Exchange type in RabbitMQ routes messages to all of the queues bound
  to it, ignoring the routing key. Let's understand how to set up a Fanout
  Exchange and how it routes messages to consumers.
---
An Exchange in RabbitMQ is a routing mechanism to send messages to queues.

RabbitMQ supports four different Exchange Types.

-   Topic Exchange
-   [Fanout Exchange](/blog/fanout-exchange-rabbitmq-dotnet/)
-   Headers Exchange
-   [**Direct Exchange**](/blog/direct-exchange-rabbitmq-dotnet/)

<EmbedCard src="https://www.youtube.com/embed/NUASc6djZqE?feature=oembed" title="FANOUT EXCHANGE TYPE  | RabbitMQ from DOTNET | Amazon MQ" />

In this blog post, let's understand

-   RabbitMQ Fanout Exchange
-   Routing messages in Fanout Exchange
-   Set up a Fanout Exchange from .NET app

I use [Amazon MQ](https://aws.amazon.com/amazon-mq/?ref=rahulpnath.com), a managed message broker service that supports ActiveMQ and RabbitMQ engine types, to host my RabbitMQ instance. However, you can use [one of the various options that RabbitMQ provides](https://www.rabbitmq.com/download.html?ref=rahulpnath.com) to host your instance,

_AWS sponsors this article and is part of my_ [_RabbitMQ Series_](/blog/tag/rabbitmq/)_._

## What is a RabbitMQ Fanout Exchange?

A Fanout Exchange type in RabbitMQ routes messages to all the queues bound to it, ignoring the routing key.

When a new message is published to a Fanout exchange, a copy is delivered to all the queues bound to it.

Fanout exchanges are ideal for broadcasting messages.

<ImageCard src="/content/images/2024/03/image-3.png" alt="Fanout Exchange routes messages to all queues bound to it. It ignores the routing keys on the messages and the Binding if any are specified." caption="Fanout Exchange routes messages to all queues bound to it. It ignores the routing keys on the messages and the Binding if any are specified." />

Fanout exchange ignores the routing keys on the messages and any Binding keys if specified.

## RabbitMQ Fanout Exchange From .NET

We will use a NuGet package, [RabbitMQ.Client](https://www.nuget.org/packages/RabbitMQ.Client?ref=rahulpnath.com), to connect and send/receive messages from RabbitMQ.

If you are new to building RabbitMQ from .NET applications, check out the Getting Started article below.

<BookmarkCard href="/blog/amazon-mq-rabbitmq-dotnet/" title="Amazon MQ RabbitMQ: A Reliable Messaging Solution for Your .NET Projects" description="RabbitMQ is a powerful open-source message broker facilitating communication between systems or applications. Let’s learn how to get started using RabbitMQ on Amazon MQ from .NET application." icon="/content/images/size/w256h256/2022/10/logo-512x512.png" />

### Creating RabbitMQ Fanout Exchange From .NET

Exchanges are created using the Channel.

The `ExchangeDeclare` the method takes in an exchange name and its type. Below is an example of creating a RabbitMQ Fanout Exchange in .NET.

```csharp
var factory = new ConnectionFactory()
{
    Uri = new Uri("YOUR RABBIT INSTANCE URI"),
    Port = 5671,
    UserName = "<USERNAME FROM CONFIGURATION FILE>",
    Password = "<PASSWORD FROM CONFIGURATION FILE>"
};

using var connection = factory.CreateConnection();
using var channel = connection.CreateModel();

var exchangeName = "weather_fanout";
channel.ExchangeDeclare(exchangeName, ExchangeType.Fanout);
```

When sending a message, the sender specifies the Exchange and routing key.

```csharp
channel.BasicPublish(exchangeName, routingKey, null, body);
```

When sending to a Fanout Exchange, the `routingKey` can be empty as the exchange ignores it.

### Set up Binding on Fanout Exchange From .NET

Messages are routed to Queues from Exchanges using the Binding information.

To create a Queue, use the `QueueDeclare` method. It will create a new Queue only if one doesn't exist with the same name.

```csharp
var factory = new ConnectionFactory()
{
    Uri = new Uri("YOUR RABBIT INSTANCE URI"),
    Port = 5671,
    UserName = "<USERNAME FROM CONFIGURATION FILE>",
    Password = "<PASSWORD FROM CONFIGURATION FILE>"
};

using var connection = factory.CreateConnection();
using var channel = connection.CreateModel();

var queueName = "nsw";
channel.QueueDeclare(queueName, false, false, false, null);
channel.QueueBind(queueName, "weather_fanout", string.Empty);
```

The above code sets up a queue `nsw` and sets up a binding with the Fanout exchange (`weather_fanout`) we created earlier.

You can create multiple queues and bind with the same exchange, if multiple consumers are interested in the messages coming to the Exchange.

<ImageCard src="/content/images/2024/03/image-4.png" alt="Fanout Exchange in AWS MQ RabbitMQ console showing the two queues and the bindings." caption="Fanout Exchange in AWS MQ RabbitMQ console showing the two queues and the bindings." />

For example, In this case, the `weather_fanout` exchange can be used to broadcast critical weather alerts, and all consumers are interested in it. To register other Queues, we can repeat the queue declaration and binding.

```csharp
var queueName = "qld";
channel.QueueDeclare(queueName, false, false, false, null);
channel.QueueBind(queueName, "weather_fanout", string.Empty);
```

Any time a message is sent to the Exchange, a copy of it is sent to both `qld` and `nsw` Queues and the consumers listening on those queues can process the messages.

<ImageCard src="/content/images/2024/03/RabbitMQ-Fanout-Exchange.gif" alt="RabbitMQ Fanout exchange sending messages to all bounded queues." caption="RabbitMQ Fanout exchange sending messages to all bounded queues." />
